diff --git a/sound/soc/samsung/i2s.c b/sound/soc/samsung/i2s.c
index f2ce03dbf02f..ec2e5f0eecce 100644
--- a/sound/soc/samsung/i2s.c
+++ b/sound/soc/samsung/i2s.c
@@ -21,24 +21,42 @@
 
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/exynos.h>
+
+#include <linux/dma/dma-pl330.h>
 
 #include <linux/platform_data/asoc-s3c.h>
 
+#if 0
+#include <plat/cpu.h>
+#endif
+
 #include "dma.h"
+#ifdef CONFIG_SND_SAMSUNG_IDMA
 #include "idma.h"
+#endif
 #include "i2s.h"
 #include "i2s-regs.h"
+#ifdef CONFIG_SND_SAMSUNG_FAKEDMA
+#include "fdma.h"
+#endif
+#include "eax.h"
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+#include "compr.h"
+#endif
 
 #define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
 
+#define I2S_DEFAULT_SLOT_NUM	2 /* stereo default */
+
 enum samsung_dai_type {
 	TYPE_PRI,
 	TYPE_SEC,
+	TYPE_COMPR,
 };
 
 struct samsung_i2s_dai_data {
 	int dai_type;
-	u32 quirks;
 };
 
 struct i2s_dai {
@@ -48,6 +66,8 @@ struct i2s_dai {
 	void __iomem	*addr;
 	/* Physical base address of SFRs */
 	u32	base;
+	/* IRQ number */
+	unsigned int	irq;
 	/* Rate of RCLK source clock */
 	unsigned long rclk_srcrate;
 	/* Frame Clock */
@@ -61,31 +81,68 @@ struct i2s_dai {
 	struct clk *clk;
 	/* Clock for generating I2S signals */
 	struct clk *op_clk;
+	struct clk *opclk0;
+	struct clk *opclk1;
 	/* Pointer to the Primary_Fifo if this is Sec_Fifo, NULL otherwise */
 	struct i2s_dai *pri_dai;
 	/* Pointer to the Secondary_Fifo if it has one, NULL otherwise */
 	struct i2s_dai *sec_dai;
+	/* Pointer to the Compress_dai if it has one, NULL otherwise */
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	struct i2s_dai *compr_dai;
+	bool is_compress;
+	bool running;
+#endif
 #define DAI_OPENED	(1 << 0) /* Dai is opened */
 #define DAI_MANAGER	(1 << 1) /* Dai is the manager */
+#define DAI_TDM_MODE	(1 << 2) /* Dai is set as TDM mode */
 	unsigned mode;
-	/* CDCLK pin direction: 0  - input, 1 - output */
-	unsigned int cdclk_out:1;
 	/* Driver for this DAI */
 	struct snd_soc_dai_driver i2s_dai_drv;
 	/* DMA parameters */
 	struct s3c_dma_params dma_playback;
 	struct s3c_dma_params dma_capture;
+#ifdef CONFIG_SND_SAMSUNG_IDMA
 	struct s3c_dma_params idma_playback;
+#endif
+#ifndef CONFIG_PM_RUNTIME
+	int enable_cnt;
+#endif
+	int	stream_cnt;
 	u32	quirks;
+	u32	amixer;
 	u32	suspend_i2smod;
 	u32	suspend_i2scon;
 	u32	suspend_i2spsr;
-	unsigned long gpios[7];	/* i2s gpio line numbers */
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	u32	suspend_i2sahb[((I2SSTR1 - I2SAHB) >> 2) + 1];
+#endif
+	u32	suspend_i2stdm;
+	/* GPIO pinctrl */
+	struct pinctrl *pinctrl;
+	/* MOD bit slice */
+	u32	lrp_b;
+	u32	cdclk_b;
+	u32	slave_b;
+	u32	rclks_b;
+	u32	txr_sht;
+	u32	txr_msk;
+	u32	sdf_sht;
+	u32	rfs_sht;
+	u32	rfs_msk;
+	u32	bfs_sht;
+	u32	bfs_msk;
+	int	slotnum;
 };
 
 /* Lock for cross i/f checks */
 static DEFINE_SPINLOCK(lock);
 
+#ifndef CONFIG_PM_RUNTIME
+static int i2s_disable(struct device *dev);
+static int i2s_enable(struct device *dev);
+#endif
+
 /* If this is the 'overlay' stereo DAI */
 static inline bool is_secondary(struct i2s_dai *i2s)
 {
@@ -95,9 +152,23 @@ static inline bool is_secondary(struct i2s_dai *i2s)
 /* If operating in SoC-Slave mode */
 static inline bool is_slave(struct i2s_dai *i2s)
 {
-	return (readl(i2s->addr + I2SMOD) & MOD_SLAVE) ? true : false;
+	return (readl(i2s->addr + I2SMOD) & i2s->slave_b) ? true : false;
 }
 
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+static DEFINE_SPINLOCK(sec_hw_lock);
+
+static void i2s_print_dai_name(struct i2s_dai *i2s, char *dai_name)
+{
+	if (i2s->is_compress)
+		snprintf(dai_name, 10, "compr");
+	else if (is_secondary(i2s))
+		snprintf(dai_name, 10, "sec");
+	else
+		snprintf(dai_name, 10, "pri");
+}
+#endif
+
 /* If this interface of the controller is transmitting data */
 static inline bool tx_active(struct i2s_dai *i2s)
 {
@@ -201,13 +272,14 @@ static inline unsigned get_rfs(struct i2s_dai *i2s)
 {
 	u32 rfs;
 
-	if (i2s->quirks & QUIRK_SUPPORTS_TDM)
-		rfs = readl(i2s->addr + I2SMOD) >> EXYNOS5420_MOD_RCLK_SHIFT;
-	else
-		rfs = (readl(i2s->addr + I2SMOD) >> MOD_RCLK_SHIFT);
-	rfs &= MOD_RCLK_MASK;
+	rfs = readl(i2s->addr + I2SMOD) >> i2s->rfs_sht;
+	rfs &= i2s->rfs_msk;
 
 	switch (rfs) {
+	case 7: return 192;
+	case 6: return 96;
+	case 5: return 128;
+	case 4: return 64;
 	case 3:	return 768;
 	case 2: return 384;
 	case 1:	return 512;
@@ -218,31 +290,43 @@ static inline unsigned get_rfs(struct i2s_dai *i2s)
 /* Write RCLK of I2S (in multiples of LRCLK) */
 static inline void set_rfs(struct i2s_dai *i2s, unsigned rfs)
 {
-	u32 mod = readl(i2s->addr + I2SMOD);
-	int rfs_shift;
-
-	if (i2s->quirks & QUIRK_SUPPORTS_TDM)
-		rfs_shift = EXYNOS5420_MOD_RCLK_SHIFT;
-	else
-		rfs_shift = MOD_RCLK_SHIFT;
-	mod &= ~(MOD_RCLK_MASK << rfs_shift);
+	u32 mod;
+	u32 val;
+	unsigned long flags;
 
 	switch (rfs) {
 	case 768:
-		mod |= (MOD_RCLK_768FS << rfs_shift);
+		val = MOD_RCLK_768FS;
 		break;
 	case 512:
-		mod |= (MOD_RCLK_512FS << rfs_shift);
+		val = MOD_RCLK_512FS;
 		break;
 	case 384:
-		mod |= (MOD_RCLK_384FS << rfs_shift);
+		val = MOD_RCLK_384FS;
+		break;
+	case 192:
+		val = EXYNOS5430_MOD_RCLK_192FS;
+		break;
+	case 128:
+		val = EXYNOS5430_MOD_RCLK_128FS;
+		break;
+	case 96:
+		val = EXYNOS5430_MOD_RCLK_96FS;
+		break;
+	case 64:
+		val = EXYNOS5430_MOD_RCLK_64FS;
 		break;
 	default:
-		mod |= (MOD_RCLK_256FS << rfs_shift);
+		val = MOD_RCLK_256FS;
 		break;
 	}
 
+	spin_lock_irqsave(&lock, flags);
+	mod = readl(i2s->addr + I2SMOD);
+	mod &= ~(i2s->rfs_msk << i2s->rfs_sht);
+	mod |= val << i2s->rfs_sht;
 	writel(mod, i2s->addr + I2SMOD);
+	spin_unlock_irqrestore(&lock, flags);
 }
 
 /* Read Bit-Clock of I2S (in multiples of LRCLK) */
@@ -250,13 +334,8 @@ static inline unsigned get_bfs(struct i2s_dai *i2s)
 {
 	u32 bfs;
 
-	if (i2s->quirks & QUIRK_SUPPORTS_TDM) {
-		bfs = readl(i2s->addr + I2SMOD) >> EXYNOS5420_MOD_BCLK_SHIFT;
-		bfs &= EXYNOS5420_MOD_BCLK_MASK;
-	} else {
-		bfs =  readl(i2s->addr + I2SMOD) >> MOD_BCLK_SHIFT;
-		bfs &= MOD_BCLK_MASK;
-	}
+	bfs = readl(i2s->addr + I2SMOD) >> i2s->bfs_sht;
+	bfs &= i2s->bfs_msk;
 
 	switch (bfs) {
 	case 8: return 256;
@@ -274,58 +353,49 @@ static inline unsigned get_bfs(struct i2s_dai *i2s)
 /* Write Bit-Clock of I2S (in multiples of LRCLK) */
 static inline void set_bfs(struct i2s_dai *i2s, unsigned bfs)
 {
-	u32 mod = readl(i2s->addr + I2SMOD);
-	int bfs_shift;
-	int tdm = i2s->quirks & QUIRK_SUPPORTS_TDM;
-
-	if (i2s->quirks & QUIRK_SUPPORTS_TDM) {
-		bfs_shift = EXYNOS5420_MOD_BCLK_SHIFT;
-		mod &= ~(EXYNOS5420_MOD_BCLK_MASK << bfs_shift);
-	} else {
-		bfs_shift = MOD_BCLK_SHIFT;
-		mod &= ~(MOD_BCLK_MASK << bfs_shift);
-	}
-
-	/* Non-TDM I2S controllers do not support BCLK > 48 * FS */
-	if (!tdm && bfs > 48) {
-		dev_err(&i2s->pdev->dev, "Unsupported BCLK divider\n");
-		return;
-	}
+	u32 mod;
+	u32 val;
+	unsigned long flags;
 
 	switch (bfs) {
 	case 48:
-		mod |= (MOD_BCLK_48FS << bfs_shift);
+		val = MOD_BCLK_48FS;
 		break;
 	case 32:
-		mod |= (MOD_BCLK_32FS << bfs_shift);
+		val = MOD_BCLK_32FS;
 		break;
 	case 24:
-		mod |= (MOD_BCLK_24FS << bfs_shift);
+		val = MOD_BCLK_24FS;
 		break;
 	case 16:
-		mod |= (MOD_BCLK_16FS << bfs_shift);
+		val = MOD_BCLK_16FS;
 		break;
 	case 64:
-		mod |= (EXYNOS5420_MOD_BCLK_64FS << bfs_shift);
+		val = EXYNOS5420_MOD_BCLK_64FS;
 		break;
 	case 96:
-		mod |= (EXYNOS5420_MOD_BCLK_96FS << bfs_shift);
+		val = EXYNOS5420_MOD_BCLK_96FS;
 		break;
 	case 128:
-		mod |= (EXYNOS5420_MOD_BCLK_128FS << bfs_shift);
+		val = EXYNOS5420_MOD_BCLK_128FS;
 		break;
 	case 192:
-		mod |= (EXYNOS5420_MOD_BCLK_192FS << bfs_shift);
+		val = EXYNOS5420_MOD_BCLK_192FS;
 		break;
 	case 256:
-		mod |= (EXYNOS5420_MOD_BCLK_256FS << bfs_shift);
+		val = EXYNOS5420_MOD_BCLK_256FS;
 		break;
 	default:
 		dev_err(&i2s->pdev->dev, "Wrong BCLK Divider!\n");
 		return;
 	}
 
+	spin_lock_irqsave(&lock, flags);
+	mod = readl(i2s->addr + I2SMOD);
+	mod &= ~(i2s->bfs_msk << i2s->bfs_sht);
+	mod |= val << i2s->bfs_sht;
 	writel(mod, i2s->addr + I2SMOD);
+	spin_unlock_irqrestore(&lock, flags);
 }
 
 /* Sample-Size */
@@ -347,7 +417,13 @@ static void i2s_txctrl(struct i2s_dai *i2s, int on)
 {
 	void __iomem *addr = i2s->addr;
 	u32 con = readl(addr + I2SCON);
-	u32 mod = readl(addr + I2SMOD) & ~MOD_MASK;
+	u32 mod;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lock, flags);
+	mod = readl(addr + I2SMOD);
+	mod &= ~(i2s->txr_msk << i2s->txr_sht);
+	mod |= MOD_TXR_TXRX << i2s->txr_sht;
 
 	if (on) {
 		con |= CON_ACTIVE;
@@ -362,9 +438,9 @@ static void i2s_txctrl(struct i2s_dai *i2s, int on)
 		}
 
 		if (any_rx_active(i2s))
-			mod |= MOD_TXRX;
+			mod |= MOD_TXR_TXRX << i2s->txr_sht;
 		else
-			mod |= MOD_TXONLY;
+			mod |= MOD_TXR_TXONLY << i2s->txr_sht;
 	} else {
 		if (is_secondary(i2s)) {
 			con |=  CON_TXSDMA_PAUSE;
@@ -376,19 +452,21 @@ static void i2s_txctrl(struct i2s_dai *i2s, int on)
 
 		if (other_tx_active(i2s)) {
 			writel(con, addr + I2SCON);
+			spin_unlock_irqrestore(&lock, flags);
 			return;
 		}
 
 		con |=  CON_TXCH_PAUSE;
 
 		if (any_rx_active(i2s))
-			mod |= MOD_RXONLY;
+			mod |= MOD_TXR_TXRX << i2s->txr_sht;
 		else
 			con &= ~CON_ACTIVE;
 	}
 
 	writel(mod, addr + I2SMOD);
 	writel(con, addr + I2SCON);
+	spin_unlock_irqrestore(&lock, flags);
 }
 
 /* RX Channel Control */
@@ -396,28 +474,36 @@ static void i2s_rxctrl(struct i2s_dai *i2s, int on)
 {
 	void __iomem *addr = i2s->addr;
 	u32 con = readl(addr + I2SCON);
-	u32 mod = readl(addr + I2SMOD) & ~MOD_MASK;
+	u32 mod;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lock, flags);
+	mod = readl(addr + I2SMOD);
+	mod &= ~(i2s->txr_msk << i2s->txr_sht);
+	mod |= MOD_TXR_TXRX << i2s->txr_sht;
 
 	if (on) {
 		con |= CON_RXDMA_ACTIVE | CON_ACTIVE;
 		con &= ~(CON_RXDMA_PAUSE | CON_RXCH_PAUSE);
 
 		if (any_tx_active(i2s))
-			mod |= MOD_TXRX;
+			mod |= MOD_TXR_TXRX << i2s->txr_sht;
 		else
-			mod |= MOD_RXONLY;
+			mod |= MOD_TXR_RXONLY << i2s->txr_sht;
 	} else {
 		con |=  CON_RXDMA_PAUSE | CON_RXCH_PAUSE;
 		con &= ~CON_RXDMA_ACTIVE;
 
 		if (any_tx_active(i2s))
-			mod |= MOD_TXONLY;
+			mod |= MOD_TXR_TXONLY << i2s->txr_sht;
 		else
 			con &= ~CON_ACTIVE;
 	}
 
 	writel(mod, addr + I2SMOD);
 	writel(con, addr + I2SCON);
+
+	spin_unlock_irqrestore(&lock, flags);
 }
 
 /* Flush FIFO of an interface */
@@ -450,39 +536,42 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 {
 	struct i2s_dai *i2s = to_info(dai);
 	struct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;
-	u32 mod = readl(i2s->addr + I2SMOD);
+	u32 mod;
+
+	mod = readl(i2s->addr + I2SMOD);
 
 	switch (clk_id) {
 	case SAMSUNG_I2S_OPCLK:
 		mod &= ~MOD_OPCLK_MASK;
 		mod |= dir;
 		break;
+
 	case SAMSUNG_I2S_CDCLK:
 		/* Shouldn't matter in GATING(CLOCK_IN) mode */
 		if (dir == SND_SOC_CLOCK_IN)
 			rfs = 0;
 
-		if ((rfs && other && other->rfs && (other->rfs != rfs)) ||
+		if ((rfs && other->rfs && (other->rfs != rfs)) ||
 				(any_active(i2s) &&
 				(((dir == SND_SOC_CLOCK_IN)
-					&& !(mod & MOD_CDCLKCON)) ||
+					&& !(mod & i2s->cdclk_b)) ||
 				((dir == SND_SOC_CLOCK_OUT)
-					&& (mod & MOD_CDCLKCON))))) {
+					&& (mod & i2s->cdclk_b))))) {
 			dev_err(&i2s->pdev->dev,
 				"%s:%d Other DAI busy\n", __func__, __LINE__);
 			return -EAGAIN;
 		}
 
 		if (dir == SND_SOC_CLOCK_IN)
-			mod |= MOD_CDCLKCON;
+			mod |= i2s->cdclk_b;
 		else
-			mod &= ~MOD_CDCLKCON;
+			mod &= ~i2s->cdclk_b;
 
 		i2s->rfs = rfs;
 		break;
 
-	case SAMSUNG_I2S_RCLKSRC_0: /* clock corrsponding to IISMOD[10] := 0 */
-	case SAMSUNG_I2S_RCLKSRC_1: /* clock corrsponding to IISMOD[10] := 1 */
+	case SAMSUNG_I2S_RCLKSRC_0: /* clock corrsponding to RCLKSRC := 0 */
+	case SAMSUNG_I2S_RCLKSRC_1: /* clock corrsponding to RCLKSRC := 1 */
 		if ((i2s->quirks & QUIRK_NO_MUXPSR)
 				|| (clk_id == SAMSUNG_I2S_RCLKSRC_0))
 			clk_id = 0;
@@ -490,11 +579,9 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 			clk_id = 1;
 
 		if (!any_active(i2s)) {
-			if (i2s->op_clk && !IS_ERR(i2s->op_clk)) {
-				if ((clk_id && !(mod & MOD_IMS_SYSMUX)) ||
-					(!clk_id && (mod & MOD_IMS_SYSMUX))) {
-					clk_disable_unprepare(i2s->op_clk);
-					clk_put(i2s->op_clk);
+			if (i2s->op_clk) {
+				if ((clk_id && !(mod & i2s->rclks_b)) ||
+					(!clk_id && (mod & i2s->rclks_b))) {
 				} else {
 					i2s->rclk_srcrate =
 						clk_get_rate(i2s->op_clk);
@@ -502,17 +589,11 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 				}
 			}
 
-			if (clk_id)
-				i2s->op_clk = clk_get(&i2s->pdev->dev,
-						"i2s_opclk1");
-			else
-				i2s->op_clk = clk_get(&i2s->pdev->dev,
-						"i2s_opclk0");
-
-			if (WARN_ON(IS_ERR(i2s->op_clk)))
-				return PTR_ERR(i2s->op_clk);
-
-			clk_prepare_enable(i2s->op_clk);
+			if (clk_id) {
+				i2s->op_clk = i2s->opclk1;
+			} else {
+				i2s->op_clk = i2s->opclk0;
+			}
 			i2s->rclk_srcrate = clk_get_rate(i2s->op_clk);
 
 			/* Over-ride the other's */
@@ -520,8 +601,8 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 				other->op_clk = i2s->op_clk;
 				other->rclk_srcrate = i2s->rclk_srcrate;
 			}
-		} else if ((!clk_id && (mod & MOD_IMS_SYSMUX))
-				|| (clk_id && !(mod & MOD_IMS_SYSMUX))) {
+		} else if ((!clk_id && (mod & i2s->rclks_b))
+				|| (clk_id && !(mod & i2s->rclks_b))) {
 			dev_err(&i2s->pdev->dev,
 				"%s:%d Other DAI busy\n", __func__, __LINE__);
 			return -EAGAIN;
@@ -533,9 +614,9 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 		}
 
 		if (clk_id == 0)
-			mod &= ~MOD_IMS_SYSMUX;
+			mod &= ~i2s->rclks_b;
 		else
-			mod |= MOD_IMS_SYSMUX;
+			mod |= i2s->rclks_b;
 		break;
 
 	default:
@@ -552,33 +633,24 @@ static int i2s_set_fmt(struct snd_soc_dai *dai,
 	unsigned int fmt)
 {
 	struct i2s_dai *i2s = to_info(dai);
-	u32 mod = readl(i2s->addr + I2SMOD);
-	int lrp_shift, sdf_shift, sdf_mask, lrp_rlow;
+	u32 mod;
 	u32 tmp = 0;
-
-	if (i2s->quirks & QUIRK_SUPPORTS_TDM) {
-		lrp_shift = EXYNOS5420_MOD_LRP_SHIFT;
-		sdf_shift = EXYNOS5420_MOD_SDF_SHIFT;
-	} else {
-		lrp_shift = MOD_LRP_SHIFT;
-		sdf_shift = MOD_SDF_SHIFT;
-	}
-
-	sdf_mask = MOD_SDF_MASK << sdf_shift;
-	lrp_rlow = MOD_LR_RLOW << lrp_shift;
+	int sdf_mask = MOD_SDF_MASK << i2s->sdf_sht;
+	unsigned long flags;
 
 	/* Format is priority */
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_RIGHT_J:
-		tmp |= lrp_rlow;
-		tmp |= (MOD_SDF_MSB << sdf_shift);
+		tmp |= i2s->lrp_b;
+		tmp |= (MOD_SDF_MSB << i2s->sdf_sht);
 		break;
 	case SND_SOC_DAIFMT_LEFT_J:
-		tmp |= lrp_rlow;
-		tmp |= (MOD_SDF_LSB << sdf_shift);
+		tmp |= i2s->lrp_b;
+		tmp |= (MOD_SDF_LSB << i2s->sdf_sht);
 		break;
 	case SND_SOC_DAIFMT_I2S:
-		tmp |= (MOD_SDF_IIS << sdf_shift);
+	case SND_SOC_DAIFMT_DSP_A: /* both are same in exynos */
+		tmp |= (MOD_SDF_IIS << i2s->sdf_sht);
 		break;
 	default:
 		dev_err(&i2s->pdev->dev, "Format not supported\n");
@@ -593,10 +665,10 @@ static int i2s_set_fmt(struct snd_soc_dai *dai,
 	case SND_SOC_DAIFMT_NB_NF:
 		break;
 	case SND_SOC_DAIFMT_NB_IF:
-		if (tmp & lrp_rlow)
-			tmp &= ~lrp_rlow;
+		if (tmp & i2s->lrp_b)
+			tmp &= ~i2s->lrp_b;
 		else
-			tmp |= lrp_rlow;
+			tmp |= i2s->lrp_b;
 		break;
 	default:
 		dev_err(&i2s->pdev->dev, "Polarity not supported\n");
@@ -605,13 +677,10 @@ static int i2s_set_fmt(struct snd_soc_dai *dai,
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBM_CFM:
-		tmp |= MOD_SLAVE;
+		tmp |= i2s->slave_b;
 		break;
 	case SND_SOC_DAIFMT_CBS_CFS:
-		/* Set default source clock in Master mode */
-		if (i2s->rclk_srcrate == 0)
-			i2s_set_sysclk(dai, SAMSUNG_I2S_RCLKSRC_0,
-							0, SND_SOC_CLOCK_IN);
+		tmp &= ~i2s->slave_b;
 		break;
 	default:
 		dev_err(&i2s->pdev->dev, "master/slave format not supported\n");
@@ -622,19 +691,58 @@ static int i2s_set_fmt(struct snd_soc_dai *dai,
 	 * Don't change the I2S mode if any controller is active on this
 	 * channel.
 	 */
+	spin_lock_irqsave(&lock, flags);
+	mod = readl(i2s->addr + I2SMOD);
 	if (any_active(i2s) &&
-		((mod & (sdf_mask | lrp_rlow | MOD_SLAVE)) != tmp)) {
+	    ((mod & (sdf_mask | i2s->lrp_b | i2s->slave_b)) != tmp)) {
 		dev_err(&i2s->pdev->dev,
 				"%s:%d Other DAI busy\n", __func__, __LINE__);
+		spin_unlock_irqrestore(&lock, flags);
 		return -EAGAIN;
 	}
 
-	mod &= ~(sdf_mask | lrp_rlow | MOD_SLAVE);
+	mod &= ~(sdf_mask | i2s->lrp_b | i2s->slave_b);
 	mod |= tmp;
 	writel(mod, i2s->addr + I2SMOD);
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+#ifdef CONFIG_SND_SOC_I2S_1840_TDM
+static int i2s_set_tdm_slot(struct snd_soc_dai *dai,
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
+{
+	struct i2s_dai *i2s = to_info(dai);
+	u32 tdm;
+
+	if (!(i2s->quirks & QUIRK_SUPPORTS_TDM)) {
+		dev_err(&i2s->pdev->dev, "TDM not supported\n");
+		return -EINVAL;
+	}
+
+	tdm = readl(i2s->addr + I2STDM);
+	tdm &= ~(TDM_TX_SLOTS_MASK << TDM_TX_SLOTS_SHIFT);
+	tdm &= ~(TDM_RX_SLOTS_MASK << TDM_RX_SLOTS_SHIFT);
+	if (slots) {
+		i2s->mode |= DAI_TDM_MODE;
+		tdm |= TDM_ENABLE;
+		tdm |= ((CONFIG_SND_SOC_I2S_TXSLOT_NUMBER-1) & TDM_TX_SLOTS_MASK)
+			<< TDM_TX_SLOTS_SHIFT;
+		tdm |= ((CONFIG_SND_SOC_I2S_RXSLOT_NUMBER-1) & TDM_RX_SLOTS_MASK)
+			<< TDM_RX_SLOTS_SHIFT;
+		pr_info("tdm mode transmission - tx: %d, rx: %d where txmask: 0x%08X, rxmask: 0x%08X\n",
+			CONFIG_SND_SOC_I2S_TXSLOT_NUMBER, CONFIG_SND_SOC_I2S_RXSLOT_NUMBER,
+			tx_mask, rx_mask);
+	} else {
+		i2s->mode &= ~DAI_TDM_MODE;
+		tdm &= ~TDM_ENABLE;
+	}
+	writel(tdm, i2s->addr + I2STDM);
 
 	return 0;
 }
+#endif
 
 static int i2s_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
@@ -642,14 +750,26 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 	struct i2s_dai *i2s = to_info(dai);
 	u32 mod = readl(i2s->addr + I2SMOD);
 
-	if (!is_secondary(i2s))
+	if (!is_secondary(i2s) &&
+		(substream->stream == SNDRV_PCM_STREAM_PLAYBACK))
 		mod &= ~(MOD_DC2_EN | MOD_DC1_EN);
 
 	switch (params_channels(params)) {
 	case 6:
-		mod |= MOD_DC2_EN;
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s->dma_playback.dma_size = 4;
+			mod |= MOD_DC2_EN | MOD_DC1_EN;
+		} else {
+			i2s->dma_capture.dma_size = 4;
+		}
+		break;
 	case 4:
-		mod |= MOD_DC1_EN;
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s->dma_playback.dma_size = 4;
+			mod |= MOD_DC1_EN;
+		} else {
+			i2s->dma_capture.dma_size = 4;
+		}
 		break;
 	case 2:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -678,8 +798,8 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 	if (is_manager(i2s))
 		mod &= ~MOD_BLC_MASK;
 
-	switch (params_width(params)) {
-	case 8:
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
 		if (is_secondary(i2s))
 			mod |= MOD_BLCS_8BIT;
 		else
@@ -687,7 +807,7 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 		if (is_manager(i2s))
 			mod |= MOD_BLC_8BIT;
 		break;
-	case 16:
+	case SNDRV_PCM_FORMAT_S16_LE:
 		if (is_secondary(i2s))
 			mod |= MOD_BLCS_16BIT;
 		else
@@ -695,7 +815,7 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 		if (is_manager(i2s))
 			mod |= MOD_BLC_16BIT;
 		break;
-	case 24:
+	case SNDRV_PCM_FORMAT_S24_LE:
 		if (is_secondary(i2s))
 			mod |= MOD_BLCS_24BIT;
 		else
@@ -710,38 +830,136 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 	}
 	writel(mod, i2s->addr + I2SMOD);
 
-	samsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+			(void *)&i2s->dma_playback);
+	else
+		snd_soc_dai_set_dma_data(dai, substream,
+			(void *)&i2s->dma_capture);
 
 	i2s->frmclk = params_rate(params);
 
+#ifdef USE_EXYNOS_AUD_SCHED
+	if ((mod & MOD_BLC_MASK) == MOD_BLC_24BIT)
+		lpass_set_sched(pid_nr(substream->pid), AUD_MODE_UHQA);
+	else if (mod & (MOD_DC2_EN | MOD_DC1_EN))
+		lpass_set_sched(pid_nr(substream->pid), AUD_MODE_UHQA);
+	else
+		lpass_set_sched(pid_nr(substream->pid), AUD_MODE_NORM);
+#endif
 	return 0;
 }
 
+static void i2s_reg_save(struct i2s_dai *i2s)
+{
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	u32 n, offset;
+#endif
+	i2s->suspend_i2smod = readl(i2s->addr + I2SMOD);
+	i2s->suspend_i2scon = readl(i2s->addr + I2SCON);
+	i2s->suspend_i2spsr = readl(i2s->addr + I2SPSR);
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	if (i2s->quirks & QUIRK_IDMA) {
+		for (n = 0, offset = I2SAHB; offset <= I2SSTR1; offset += 4)
+			i2s->suspend_i2sahb[n++] = readl(i2s->addr + offset);
+	}
+#endif
+	if (i2s->quirks & QUIRK_SUPPORTS_TDM)
+		i2s->suspend_i2stdm = readl(i2s->addr + I2STDM);
+
+	dev_dbg(&i2s->pdev->dev, "Registers of I2S are saved\n");
+
+	return;
+}
+
+static void i2s_reg_restore(struct i2s_dai *i2s)
+{
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	u32 n, offset;
+#endif
+	writel(i2s->suspend_i2smod, i2s->addr + I2SMOD);
+	writel(i2s->suspend_i2scon, i2s->addr + I2SCON);
+	writel(i2s->suspend_i2spsr, i2s->addr + I2SPSR);
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	if (i2s->quirks & QUIRK_IDMA) {
+		for (n = 0, offset = I2SAHB; offset <= I2SSTR1; offset += 4)
+			writel(i2s->suspend_i2sahb[n++], i2s->addr + offset);
+	}
+#endif
+	if (i2s->quirks & QUIRK_SUPPORTS_TDM)
+		writel(i2s->suspend_i2stdm, i2s->addr + I2STDM);
+
+	dev_dbg(&i2s->pdev->dev, "Registers of I2S are restored\n");
+
+	return;
+}
+
 /* We set constraints on the substream acc to the version of I2S */
 static int i2s_startup(struct snd_pcm_substream *substream,
 	  struct snd_soc_dai *dai)
 {
 	struct i2s_dai *i2s = to_info(dai);
 	struct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;
+	struct platform_device *pdev = NULL;
 	unsigned long flags;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	char dai_name[10];
+
+	i2s_print_dai_name(i2s, dai_name);
+	pr_info("%s : %s --\n", __func__, dai_name);
+#else
+	pr_info("%s : %s --\n", __func__, is_secondary(i2s)? "sec" : "pri");
+#endif
+
+#ifdef USE_EXYNOS_AUD_SCHED
+	lpass_set_sched(pid_nr(substream->pid), AUD_MODE_DEFAULT);
+#endif
+#ifdef USE_EXYNOS_AUD_CPU_HOTPLUG
+	if (!is_secondary(i2s))
+		lpass_get_cpu_hotplug();
+#endif
+	lpass_add_stream();
+
+	pdev = is_secondary(i2s) ? i2s->pri_dai->pdev : i2s->pdev;
+#ifdef CONFIG_PM_RUNTIME
+	pm_runtime_get_sync(&pdev->dev);
+#else
+	i2s_enable(&pdev->dev);
+#endif
 
 	spin_lock_irqsave(&lock, flags);
 
-	i2s->mode |= DAI_OPENED;
+	if (!i2s->stream_cnt) {
+		i2s->mode |= DAI_OPENED;
 
-	if (is_manager(other))
-		i2s->mode &= ~DAI_MANAGER;
-	else
-		i2s->mode |= DAI_MANAGER;
+		if (is_manager(other))
+			i2s->mode &= ~DAI_MANAGER;
+		else
+			i2s->mode |= DAI_MANAGER;
 
-	if (!any_active(i2s) && (i2s->quirks & QUIRK_NEED_RSTCLR))
-		writel(CON_RSTCLR, i2s->addr + I2SCON);
+		if (is_opened(other))
+			i2s->mode |= other->mode & DAI_TDM_MODE;
 
+		/* Enforce set_sysclk in Master mode */
+		i2s->rclk_srcrate = 0;
+
+		if (!any_active(i2s) && (i2s->quirks & QUIRK_NEED_RSTCLR))
+			writel(CON_RSTCLR, i2s->addr + I2SCON);
+
+		if (!any_tx_active(i2s) && (i2s->quirks & QUIRK_SEC_DAI)) {
+			i2s_fifo(i2s, FIC_TXFLUSH);
+			i2s_fifo(other, FIC_TXFLUSH);
+		}
+	}
+
+	i2s->stream_cnt++;
 	spin_unlock_irqrestore(&lock, flags);
 
-	if (!is_opened(other) && i2s->cdclk_out)
-		i2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,
-				0, SND_SOC_CLOCK_OUT);
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	pr_info("%s : %s --\n", __func__, dai_name);
+#else
+	pr_info("%s : %s --\n", __func__, is_secondary(i2s)? "sec" : "pri");
+#endif
 	return 0;
 }
 
@@ -750,31 +968,61 @@ static void i2s_shutdown(struct snd_pcm_substream *substream,
 {
 	struct i2s_dai *i2s = to_info(dai);
 	struct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;
+	struct platform_device *pdev = NULL;
 	unsigned long flags;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	char dai_name[10];
 
+	i2s_print_dai_name(i2s, dai_name);
+	pr_info("%s : %s --\n", __func__, dai_name);
+#else
+	pr_info("%s : %s ++\n", __func__, is_secondary(i2s)? "sec" : "pri");
+#endif
 	spin_lock_irqsave(&lock, flags);
 
-	i2s->mode &= ~DAI_OPENED;
-	i2s->mode &= ~DAI_MANAGER;
+	/*
+	 * Primary  DAI can be opened for both playback and capture, hence we
+	 * need to check the status of the other stream before resetting the
+	 * DAI parameters. The issues comes up, if there is a DMA timeout while
+	 * processing the other stream and the trigger() API of that stream is
+	 * called again. The trigger() API would call config_setup() which would
+	 * reconfigure the hardware with reset values.
+	 */
+	i2s->stream_cnt--;
+	if(!i2s->stream_cnt) {
+		i2s->mode &= ~DAI_OPENED;
+		i2s->mode &= ~DAI_MANAGER;
+		i2s->mode &= ~DAI_TDM_MODE;
+
+		if (is_opened(other)) {
+			other->mode |= DAI_MANAGER;
+			i2s->mode |= other->mode & DAI_TDM_MODE;
+		}
 
-	if (is_opened(other)) {
-		other->mode |= DAI_MANAGER;
-	} else {
-		u32 mod = readl(i2s->addr + I2SMOD);
-		i2s->cdclk_out = !(mod & MOD_CDCLKCON);
-		if (other)
-			other->cdclk_out = i2s->cdclk_out;
+		/* Reset any constraint on RFS and BFS */
+		i2s->rfs = 0;
+		i2s->bfs = 0;
 	}
-	/* Reset any constraint on RFS and BFS */
-	i2s->rfs = 0;
-	i2s->bfs = 0;
 
 	spin_unlock_irqrestore(&lock, flags);
 
-	/* Gate CDCLK by default */
-	if (!is_opened(other))
-		i2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,
-				0, SND_SOC_CLOCK_IN);
+	pdev = is_secondary(i2s) ? i2s->pri_dai->pdev : i2s->pdev;
+#ifdef CONFIG_PM_RUNTIME
+	pm_runtime_put_sync(&pdev->dev);
+#else
+	i2s_disable(&pdev->dev);
+#endif
+	lpass_remove_stream();
+
+#ifdef USE_EXYNOS_AUD_CPU_HOTPLUG
+	if (!is_secondary(i2s))
+		lpass_put_cpu_hotplug();
+#endif
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	pr_info("%s : %s --\n", __func__, dai_name);
+#else
+	pr_info("%s : %s --\n", __func__, is_secondary(i2s)? "sec" : "pri");
+#endif
 }
 
 static int config_setup(struct i2s_dai *i2s)
@@ -792,24 +1040,27 @@ static int config_setup(struct i2s_dai *i2s)
 
 	/* Select least possible multiple(2) if no constraint set */
 	if (!bfs)
-		bfs = blc * 2;
+		bfs = blc * i2s->slotnum;
 
 	rfs = i2s->rfs;
 
 	if (!rfs && other)
 		rfs = other->rfs;
 
-	if ((rfs == 256 || rfs == 512) && (blc == 24)) {
-		dev_err(&i2s->pdev->dev,
-			"%d-RFS not supported for 24-blc\n", rfs);
-		return -EINVAL;
-	}
-
 	if (!rfs) {
 		if (bfs == 16 || bfs == 32)
 			rfs = 256;
-		else
+		else if (bfs == 48)
 			rfs = 384;
+		else
+			rfs = 512;
+		rfs /= (i2s->slotnum / I2S_DEFAULT_SLOT_NUM);
+	}
+
+	if ((rfs % bfs) || (rfs > 768)) {
+		dev_err(&i2s->pdev->dev,
+			"%d-RFS not supported for %d-BFS\n", rfs, bfs);
+		return -EINVAL;
 	}
 
 	/* If already setup and running */
@@ -827,7 +1078,7 @@ static int config_setup(struct i2s_dai *i2s)
 		return 0;
 
 	if (!(i2s->quirks & QUIRK_NO_MUXPSR)) {
-		psr = i2s->rclk_srcrate / i2s->frmclk / rfs;
+		psr = (i2s->rclk_srcrate + (rfs / 2)) / i2s->frmclk / rfs;
 		writel(((psr - 1) << 8) | PSR_PSREN, i2s->addr + I2SPSR);
 		dev_dbg(&i2s->pdev->dev,
 			"RCLK_SRC=%luHz PSR=%u, RCLK=%dfs, BCLK=%dfs\n",
@@ -841,8 +1092,7 @@ static int i2s_trigger(struct snd_pcm_substream *substream,
 	int cmd, struct snd_soc_dai *dai)
 {
 	int capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct i2s_dai *i2s = to_info(rtd->cpu_dai);
+	struct i2s_dai *i2s = to_info(dai);
 	unsigned long flags;
 
 	switch (cmd) {
@@ -856,11 +1106,28 @@ static int i2s_trigger(struct snd_pcm_substream *substream,
 			return -EINVAL;
 		}
 
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		if (!capture && is_secondary(i2s)) {
+			spin_lock(&sec_hw_lock);
+			i2s->running = true;
+			if ((i2s->is_compress && i2s->sec_dai->running) ||
+			   (!i2s->is_compress && i2s->compr_dai->running)) {
+				spin_unlock(&sec_hw_lock);
+				break;
+			}
+		}
+#endif
+
 		if (capture)
 			i2s_rxctrl(i2s, 1);
 		else
 			i2s_txctrl(i2s, 1);
 
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		if (!capture && is_secondary(i2s))
+			spin_unlock(&sec_hw_lock);
+#endif
+
 		local_irq_restore(flags);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -868,14 +1135,32 @@ static int i2s_trigger(struct snd_pcm_substream *substream,
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		local_irq_save(flags);
 
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		if (!capture && is_secondary(i2s)) {
+			spin_lock(&sec_hw_lock);
+			i2s->running = false;
+			if ((i2s->is_compress && i2s->sec_dai->running) ||
+			   (!i2s->is_compress && i2s->compr_dai->running)) {
+				spin_unlock(&sec_hw_lock);
+				break;
+			}
+		}
+#endif
+
 		if (capture) {
 			i2s_rxctrl(i2s, 0);
 			i2s_fifo(i2s, FIC_RXFLUSH);
 		} else {
 			i2s_txctrl(i2s, 0);
-			i2s_fifo(i2s, FIC_TXFLUSH);
+			if (!(i2s->quirks & QUIRK_SEC_DAI))
+				i2s_fifo(i2s, FIC_TXFLUSH);
 		}
 
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		if (!capture && is_secondary(i2s))
+			spin_unlock(&sec_hw_lock);
+#endif
+
 		local_irq_restore(flags);
 		break;
 	}
@@ -899,6 +1184,15 @@ static int i2s_set_clkdiv(struct snd_soc_dai *dai,
 		}
 		i2s->bfs = div;
 		break;
+	case SAMSUNG_I2S_DIV_RCLK:
+		if ((any_active(i2s) && div && (get_rfs(i2s) != div))
+			|| (other && other->rfs && (other->rfs != div))) {
+			dev_err(&i2s->pdev->dev,
+				"%s:%d Other DAI busy\n", __func__, __LINE__);
+			return -EAGAIN;
+		}
+		i2s->rfs = div;
+		break;
 	default:
 		dev_err(&i2s->pdev->dev,
 			"Invalid clock divider(%d)\n", div_id);
@@ -925,14 +1219,151 @@ i2s_delay(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
 	return delay;
 }
 
+static void i2s_init_bit_slice(struct i2s_dai *i2s)
+{
+	if (i2s->quirks & QUIRK_SUPPORTS_TDM) {	/* IIS V5.1 (new) */
+		if (i2s->quirks & QUIRK_SUPPORTS_LOW_RFS) {
+			i2s->lrp_b   = EXYNOS5430_MOD_LRP;
+			i2s->cdclk_b = EXYNOS5430_MOD_CDCLKCON;
+			i2s->slave_b = EXYNOS5430_MOD_SLAVE;
+			i2s->rclks_b = EXYNOS5430_MOD_RCLKSRC;
+			i2s->txr_sht = EXYNOS5430_MOD_TXR_SHIFT;
+			i2s->txr_msk = EXYNOS5430_MOD_TXR_MASK;
+			i2s->sdf_sht = EXYNOS5430_MOD_SDF_SHIFT;
+			i2s->rfs_sht = EXYNOS5430_MOD_RCLK_SHIFT;
+			i2s->rfs_msk = EXYNOS5430_MOD_RCLK_MASK;
+			i2s->bfs_sht = EXYNOS5430_MOD_BCLK_SHIFT;
+			i2s->bfs_msk = EXYNOS5430_MOD_BCLK_MASK;
+		} else {
+			i2s->lrp_b   = EXYNOS5420_MOD_LRP;
+			i2s->cdclk_b = EXYNOS5420_MOD_CDCLKCON;
+			i2s->slave_b = EXYNOS5420_MOD_SLAVE;
+			i2s->rclks_b = EXYNOS5420_MOD_RCLKSRC;
+			i2s->txr_sht = EXYNOS5420_MOD_TXR_SHIFT;
+			i2s->txr_msk = EXYNOS5420_MOD_TXR_MASK;
+			i2s->sdf_sht = EXYNOS5420_MOD_SDF_SHIFT;
+			i2s->rfs_sht = EXYNOS5420_MOD_RCLK_SHIFT;
+			i2s->rfs_msk = EXYNOS5420_MOD_RCLK_MASK;
+			i2s->bfs_sht = EXYNOS5420_MOD_BCLK_SHIFT;
+			i2s->bfs_msk = EXYNOS5420_MOD_BCLK_MASK;
+		}
+	} else if (i2s->quirks & QUIRK_I2S_STR_MODE) {
+		i2s->lrp_b   = I2S_STR_MOD_LRP;
+		i2s->cdclk_b = I2S_STR_MOD_CDCLKCON;
+		i2s->slave_b = I2S_STR_MOD_SLAVE;
+		i2s->rclks_b = I2S_STR_MOD_RCLKSRC;
+		i2s->txr_sht = I2S_STR_MOD_TXR_SHIFT;
+		i2s->txr_msk = I2S_STR_MOD_TXR_MASK;
+		i2s->sdf_sht = I2S_STR_MOD_SDF_SHIFT;
+		i2s->rfs_sht = I2S_STR_MOD_RCLK_SHIFT;
+		i2s->rfs_msk = I2S_STR_MOD_RCLK_MASK;
+		i2s->bfs_sht = I2S_STR_MOD_BCLK_SHIFT;
+		i2s->bfs_msk = I2S_STR_MOD_BCLK_MASK;
+	} else {				/* IIS V5.1 (old) */
+		i2s->lrp_b   = MOD_LRP;
+		i2s->cdclk_b = MOD_CDCLKCON;
+		i2s->slave_b = MOD_SLAVE;
+		i2s->rclks_b = MOD_RCLKSRC;
+		i2s->txr_sht = MOD_TXR_SHIFT;
+		i2s->txr_msk = MOD_TXR_MASK;
+		i2s->sdf_sht = MOD_SDF_SHIFT;
+		i2s->rfs_sht = MOD_RCLK_SHIFT;
+		i2s->rfs_msk = MOD_RCLK_MASK;
+		i2s->bfs_sht = MOD_BCLK_SHIFT;
+		i2s->bfs_msk = MOD_BCLK_MASK;
+	}
+}
+
+#ifdef CONFIG_SND_SAMSUNG_FAKEDMA
+int i2s_get_fifo_cnt(struct snd_pcm_substream * substream,
+			struct snd_soc_dai *dai)
+{
+	struct i2s_dai *i2s = to_info(dai);
+#ifdef CONFIG_SOC_EXYNOS7420
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (i2s->quirks & QUIRK_SEC_DAI)
+			return (readl(i2s->addr + I2SFIC1) & 0x7F);
+		else
+			return (readl(i2s->addr + I2SFIC) & 0x7F);
+	} else {
+		if (is_secondary(i2s))
+			return ((readl(i2s->addr + I2SFICS) >> 8) & 0x7F);
+		else if (i2s->quirks & QUIRK_SEC_DAI)
+			return (readl(i2s->addr + I2SFIC) & 0x7F);
+		else
+			return ((readl(i2s->addr + I2SFIC) >> 8) & 0x7F);
+	}
+#else
+	u32 fic = readl(i2s->addr + I2SFIC);
+	u32 fics = readl(i2s->addr + I2SFICS);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		return (fic & 0x7F);
+	else if (is_secondary(i2s))
+		return ((fics >> 8) & 0x7F);
+	else
+		return ((fic >> 8) & 0x7F);
+#endif
+}
+
+void i2s_write_fifo(struct snd_pcm_substream * substream,
+			struct snd_soc_dai *dai, u32 val)
+{
+	struct i2s_dai *i2s = to_info(dai);
+
+	writel(val, i2s->addr + (is_secondary(i2s) ? I2STXDS : I2STXD));
+}
+
+u32 i2s_read_fifo(struct snd_pcm_substream * substream,
+			struct snd_soc_dai *dai)
+{
+	struct i2s_dai *i2s = to_info(dai);
+
+	return readl(i2s->addr + I2SRXD);
+}
+
+static struct samsung_fdma_cpu_ops cpu_ops = {
+	.get_fifo_cnt	= i2s_get_fifo_cnt,
+	.write_fifo	= i2s_write_fifo,
+	.read_fifo	= i2s_read_fifo
+};
+#endif
+
+static void i2s_cfg_gpio(struct i2s_dai *i2s, const char *name)
+{
+	struct platform_device *pdev;
+	struct s3c_audio_pdata *i2s_pdata;
+	struct pinctrl_state *pin_state;
+
+	pdev = is_secondary(i2s) ? i2s->pri_dai->pdev : i2s->pdev;
+
+	if (pdev->dev.of_node) {
+		pin_state = pinctrl_lookup_state(i2s->pinctrl, name);
+		if (IS_ERR(pin_state))
+			goto err;
+		if (pinctrl_select_state(i2s->pinctrl, pin_state) < 0)
+			goto err;
+	} else {
+		i2s_pdata = pdev->dev.platform_data;
+		if (i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev))
+			goto err;
+	}
+
+	return;
+err:
+	dev_dbg(&pdev->dev, "Unable to configure i2s gpio as %s\n", name);
+	return;
+}
+
 #ifdef CONFIG_PM
 static int i2s_suspend(struct snd_soc_dai *dai)
 {
 	struct i2s_dai *i2s = to_info(dai);
 
-	i2s->suspend_i2smod = readl(i2s->addr + I2SMOD);
-	i2s->suspend_i2scon = readl(i2s->addr + I2SCON);
-	i2s->suspend_i2spsr = readl(i2s->addr + I2SPSR);
+	if (dai->active) {
+		i2s_cfg_gpio(i2s, "idle");
+		i2s_reg_save(i2s);
+	}
 
 	return 0;
 }
@@ -941,27 +1372,53 @@ static int i2s_resume(struct snd_soc_dai *dai)
 {
 	struct i2s_dai *i2s = to_info(dai);
 
-	writel(i2s->suspend_i2scon, i2s->addr + I2SCON);
-	writel(i2s->suspend_i2smod, i2s->addr + I2SMOD);
-	writel(i2s->suspend_i2spsr, i2s->addr + I2SPSR);
+	if (dai->active) {
+		i2s_reg_restore(i2s);
+		i2s_cfg_gpio(i2s, "default");
+	}
+
+	return 0;
+}
+
+static int i2s_suspend_force(struct snd_soc_dai *dai)
+{
+	struct i2s_dai *i2s = to_info(dai);
+
+	i2s_cfg_gpio(i2s, "idle");
+	i2s_reg_save(i2s);
+
+	return 0;
+}
+
+static int i2s_resume_force(struct snd_soc_dai *dai)
+{
+	struct i2s_dai *i2s = to_info(dai);
+
+	i2s_reg_restore(i2s);
+	i2s_cfg_gpio(i2s, "default");
 
 	return 0;
 }
 #else
 #define i2s_suspend NULL
 #define i2s_resume  NULL
+#define i2s_suspend_force NULL
+#define i2s_resume_force  NULL
 #endif
 
+static const struct snd_soc_dai_ops samsung_i2s_dai_ops;
 static int samsung_i2s_dai_probe(struct snd_soc_dai *dai)
 {
 	struct i2s_dai *i2s = to_info(dai);
 	struct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	struct i2s_dai *compr = i2s->compr_dai;
 
-	if (other && other->clk) { /* If this is probe on secondary */
-		samsung_asoc_init_dma_data(dai, &other->sec_dai->dma_playback,
-					   NULL);
+	if ((other && other->clk) || i2s->is_compress) /* If this is probe on secondary */
+#else
+	if (other && other->clk) /* If this is probe on secondary */
+#endif
 		goto probe_exit;
-	}
 
 	i2s->addr = ioremap(i2s->base, 0x100);
 	if (i2s->addr == NULL) {
@@ -969,33 +1426,97 @@ static int samsung_i2s_dai_probe(struct snd_soc_dai *dai)
 		return -ENXIO;
 	}
 
+#ifndef CONFIG_SOC_EXYNOS8890
 	i2s->clk = clk_get(&i2s->pdev->dev, "iis");
 	if (IS_ERR(i2s->clk)) {
 		dev_err(&i2s->pdev->dev, "failed to get i2s_clock\n");
 		iounmap(i2s->addr);
 		return -ENOENT;
 	}
-	clk_prepare_enable(i2s->clk);
 
-	samsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);
+	i2s->opclk1 = clk_get(&i2s->pdev->dev, "i2s_opclk1");
+	if (IS_ERR(i2s->opclk1)) {
+		dev_err(&i2s->pdev->dev, "failed to get i2s_opclk1\n");
+		clk_put(i2s->clk);
+		iounmap(i2s->addr);
+		return -ENOENT;
+	}
+
+	i2s->opclk0 = clk_get(&i2s->pdev->dev, "i2s_opclk0");
+	if (IS_ERR(i2s->opclk0)) {
+		dev_err(&i2s->pdev->dev, "failed to get i2s_opclk0\n");
+		clk_put(i2s->opclk1);
+		clk_put(i2s->clk);
+		iounmap(i2s->addr);
+		return -ENOENT;
+	}
+#else
+	i2s->clk = clk_get(&i2s->pdev->dev, "gate_aud_mi2s");
+	if (IS_ERR(i2s->clk)) {
+		dev_err(&i2s->pdev->dev, "failed to get gate_aud_mi2s clock\n");
+		iounmap(i2s->addr);
+		return -ENOENT;
+	}
+
+	i2s->opclk1 = clk_get(&i2s->pdev->dev, "gate_aud_sclk_mi2s");
+	if (IS_ERR(i2s->opclk1) &&
+		!(i2s->opclk1 == ERR_PTR(-ENOENT))) {
+		dev_err(&i2s->pdev->dev, "failed to get i2s_opclk1\n");
+		clk_put(i2s->clk);
+		iounmap(i2s->addr);
+		return -ENOENT;
+	}
+
+	i2s->opclk0 = clk_get(&i2s->pdev->dev, "gate_aud_lpass");
+	if (IS_ERR(i2s->opclk0) &&
+		!(i2s->opclk0 == ERR_PTR(-ENOENT))) {
+		dev_err(&i2s->pdev->dev, "failed to get i2s_opclk0\n");
+		clk_put(i2s->opclk1);
+		clk_put(i2s->clk);
+		iounmap(i2s->addr);
+		return -ENOENT;
+	}
+#endif
+
 
 	if (other) {
 		other->addr = i2s->addr;
 		other->clk = i2s->clk;
+		other->opclk0 = i2s->opclk0;
+		other->opclk1 = i2s->opclk1;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		if (compr) {
+			compr->addr = i2s->addr;
+			compr->clk = i2s->clk;
+			compr->opclk0 = i2s->opclk0;
+			compr->opclk1 = i2s->opclk1;
+		}
+#endif
 	}
 
-	if (i2s->quirks & QUIRK_NEED_RSTCLR)
-		writel(CON_RSTCLR, i2s->addr + I2SCON);
-
-	if (i2s->quirks & QUIRK_SEC_DAI)
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	if (i2s->quirks & QUIRK_IDMA)
 		idma_reg_addr_init(i2s->addr,
 					i2s->sec_dai->idma_playback.dma_addr);
+#endif
+	if (i2s->amixer)
+		eax_dai_register(dai, &samsung_i2s_dai_ops,
+					i2s_suspend_force, i2s_resume_force);
 
 probe_exit:
+	clk_prepare_enable(i2s->opclk0);
+	clk_prepare_enable(i2s->opclk1);
+	clk_prepare_enable(i2s->clk);
+
+	/* Initialize bit slice as I2S HW version */
+	i2s_init_bit_slice(i2s);
+
+	if (i2s->quirks & QUIRK_NEED_RSTCLR)
+		writel(CON_RSTCLR, i2s->addr + I2SCON);
+
 	/* Reset any constraint on RFS and BFS */
 	i2s->rfs = 0;
 	i2s->bfs = 0;
-	i2s->rclk_srcrate = 0;
 	i2s_txctrl(i2s, 0);
 	i2s_rxctrl(i2s, 0);
 	i2s_fifo(i2s, FIC_TXFLUSH);
@@ -1007,6 +1528,9 @@ probe_exit:
 		i2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,
 				0, SND_SOC_CLOCK_IN);
 
+	clk_disable_unprepare(i2s->clk);
+	clk_disable_unprepare(i2s->opclk0);
+	clk_disable_unprepare(i2s->opclk1);
 	return 0;
 }
 
@@ -1020,14 +1544,18 @@ static int samsung_i2s_dai_remove(struct snd_soc_dai *dai)
 		if (i2s->quirks & QUIRK_NEED_RSTCLR)
 			writel(0, i2s->addr + I2SCON);
 
-		clk_disable_unprepare(i2s->clk);
 		clk_put(i2s->clk);
+		clk_put(i2s->opclk0);
+		clk_put(i2s->opclk1);
 
 		iounmap(i2s->addr);
 	}
 
 	i2s->clk = NULL;
 
+	if (i2s->amixer)
+		eax_dai_unregister();
+
 	return 0;
 }
 
@@ -1037,6 +1565,9 @@ static const struct snd_soc_dai_ops samsung_i2s_dai_ops = {
 	.set_fmt = i2s_set_fmt,
 	.set_clkdiv = i2s_set_clkdiv,
 	.set_sysclk = i2s_set_sysclk,
+#ifdef CONFIG_SND_SOC_I2S_1840_TDM
+	.set_tdm_slot = i2s_set_tdm_slot,
+#endif
 	.startup = i2s_startup,
 	.shutdown = i2s_shutdown,
 	.delay = i2s_delay,
@@ -1046,13 +1577,14 @@ static const struct snd_soc_component_driver samsung_i2s_component = {
 	.name		= "samsung-i2s",
 };
 
-#define SAMSUNG_I2S_RATES	SNDRV_PCM_RATE_8000_96000
+#define SAMSUNG_I2S_RATES	SNDRV_PCM_RATE_8000_192000
 
 #define SAMSUNG_I2S_FMTS	(SNDRV_PCM_FMTBIT_S8 | \
 					SNDRV_PCM_FMTBIT_S16_LE | \
 					SNDRV_PCM_FMTBIT_S24_LE)
 
-static struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)
+static struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev,
+				     enum samsung_dai_type type, u32 quirks)
 {
 	struct i2s_dai *i2s;
 	int ret;
@@ -1062,6 +1594,8 @@ static struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)
 		return NULL;
 
 	i2s->pdev = pdev;
+	i2s->quirks = quirks;
+	i2s->stream_cnt = 0;
 	i2s->pri_dai = NULL;
 	i2s->sec_dai = NULL;
 	i2s->i2s_dai_drv.symmetric_rates = 1;
@@ -1070,23 +1604,32 @@ static struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)
 	i2s->i2s_dai_drv.ops = &samsung_i2s_dai_ops;
 	i2s->i2s_dai_drv.suspend = i2s_suspend;
 	i2s->i2s_dai_drv.resume = i2s_resume;
-	i2s->i2s_dai_drv.playback.channels_min = 1;
-	i2s->i2s_dai_drv.playback.channels_max = 2;
+	i2s->i2s_dai_drv.playback.channels_min = 2;
+	i2s->i2s_dai_drv.playback.channels_max = CONFIG_SND_SOC_I2S_TXSLOT_NUMBER;
 	i2s->i2s_dai_drv.playback.rates = SAMSUNG_I2S_RATES;
 	i2s->i2s_dai_drv.playback.formats = SAMSUNG_I2S_FMTS;
 
-	if (!sec) {
+	if (type == TYPE_PRI) {
 		i2s->i2s_dai_drv.capture.channels_min = 1;
-		i2s->i2s_dai_drv.capture.channels_max = 2;
+		i2s->i2s_dai_drv.capture.channels_max = CONFIG_SND_SOC_I2S_RXSLOT_NUMBER;
 		i2s->i2s_dai_drv.capture.rates = SAMSUNG_I2S_RATES;
 		i2s->i2s_dai_drv.capture.formats = SAMSUNG_I2S_FMTS;
 		dev_set_drvdata(&i2s->pdev->dev, i2s);
-	} else {	/* Create a new platform_device for Secondary */
+	} else if (type == TYPE_SEC) {
+		/* Create a new platform_device for Secondary */
 		i2s->pdev = platform_device_alloc("samsung-i2s-sec", -1);
-		if (!i2s->pdev)
+		if (IS_ERR(i2s->pdev))
 			return NULL;
 
-		i2s->pdev->dev.parent = &pdev->dev;
+		platform_set_drvdata(i2s->pdev, i2s);
+		ret = platform_device_add(i2s->pdev);
+		if (ret < 0)
+			return NULL;
+	} else if (type == TYPE_COMPR) {
+		/* Create a new platform_device for Secondary */
+		i2s->pdev = platform_device_alloc("samsung-i2s-compr", -1);
+		if (IS_ERR(i2s->pdev))
+			return NULL;
 
 		platform_set_drvdata(i2s->pdev, i2s);
 		ret = platform_device_add(i2s->pdev);
@@ -1094,23 +1637,24 @@ static struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)
 			return NULL;
 	}
 
+
 	return i2s;
 }
 
 static const struct of_device_id exynos_i2s_match[];
 
-static inline const struct samsung_i2s_dai_data *samsung_i2s_get_driver_data(
-						struct platform_device *pdev)
+static inline int samsung_i2s_get_driver_data(struct platform_device *pdev)
 {
 #ifdef CONFIG_OF
+	struct samsung_i2s_dai_data *data;
 	if (pdev->dev.of_node) {
 		const struct of_device_id *match;
 		match = of_match_node(exynos_i2s_match, pdev->dev.of_node);
-		return match->data;
+		data = (struct samsung_i2s_dai_data *) match->data;
+		return data->dai_type;
 	} else
 #endif
-		return (struct samsung_i2s_dai_data *)
-				platform_get_device_id(pdev)->driver_data;
+		return platform_get_device_id(pdev)->driver_data;
 }
 
 #ifdef CONFIG_PM_RUNTIME
@@ -1118,7 +1662,14 @@ static int i2s_runtime_suspend(struct device *dev)
 {
 	struct i2s_dai *i2s = dev_get_drvdata(dev);
 
+	pr_debug("%s entered\n", __func__);
+
+	i2s_cfg_gpio(i2s, "idle");
+	i2s_reg_save(i2s);
 	clk_disable_unprepare(i2s->clk);
+	clk_disable_unprepare(i2s->opclk0);
+	clk_disable_unprepare(i2s->opclk1);
+	lpass_put_sync(dev);
 
 	return 0;
 }
@@ -1127,7 +1678,58 @@ static int i2s_runtime_resume(struct device *dev)
 {
 	struct i2s_dai *i2s = dev_get_drvdata(dev);
 
+	pr_debug("%s entered\n", __func__);
+
+	lpass_get_sync(dev);
+	clk_prepare_enable(i2s->opclk0);
+	clk_prepare_enable(i2s->opclk1);
+	clk_prepare_enable(i2s->clk);
+	i2s_reg_restore(i2s);
+	i2s_cfg_gpio(i2s, "default");
+
+	return 0;
+}
+#else
+static int i2s_disable(struct device *dev)
+{
+	struct i2s_dai *i2s = dev_get_drvdata(dev);
+
+	spin_lock(&lock);
+	i2s->enable_cnt--;
+	if (i2s->enable_cnt) {
+		spin_unlock(&lock);
+		return 1;
+	}
+	spin_unlock(&lock);
+
+	i2s_cfg_gpio(i2s, "idle");
+	i2s_reg_save(i2s);
+	clk_disable_unprepare(i2s->clk);
+	clk_disable_unprepare(i2s->opclk0);
+	clk_disable_unprepare(i2s->opclk1);
+	lpass_put_sync(dev);
+
+	return 0;
+}
+
+static int i2s_enable(struct device *dev)
+{
+	struct i2s_dai *i2s = dev_get_drvdata(dev);
+
+	spin_lock(&lock);
+	i2s->enable_cnt++;
+	if (i2s->enable_cnt > 1) {
+		spin_unlock(&lock);
+		return 1;
+	}
+	spin_unlock(&lock);
+
+	lpass_get_sync(dev);
+	clk_prepare_enable(i2s->opclk0);
+	clk_prepare_enable(i2s->opclk1);
 	clk_prepare_enable(i2s->clk);
+	i2s_reg_restore(i2s);
+	i2s_cfg_gpio(i2s, "default");
 
 	return 0;
 }
@@ -1136,31 +1738,56 @@ static int i2s_runtime_resume(struct device *dev)
 static int samsung_i2s_probe(struct platform_device *pdev)
 {
 	struct i2s_dai *pri_dai, *sec_dai = NULL;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+	struct i2s_dai *compr_dai = NULL;
+#endif
 	struct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;
 	struct samsung_i2s *i2s_cfg = NULL;
 	struct resource *res;
-	u32 regs_base, quirks = 0, idma_addr = 0;
+	u32 regs_base, quirks = 0;
+	u32 amixer = 0;
+	int slotnum;
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	u32 idma_addr;
+#endif
 	struct device_node *np = pdev->dev.of_node;
-	const struct samsung_i2s_dai_data *i2s_dai_data;
+	struct pinctrl *pinctrl;
+	enum samsung_dai_type samsung_dai_type;
 	int ret = 0;
 
 	/* Call during Seconday interface registration */
-	i2s_dai_data = samsung_i2s_get_driver_data(pdev);
+	samsung_dai_type = samsung_i2s_get_driver_data(pdev);
 
-	if (i2s_dai_data->dai_type == TYPE_SEC) {
-		sec_dai = dev_get_drvdata(&pdev->dev);
-		if (!sec_dai) {
+	if (samsung_dai_type != TYPE_PRI) {
+		struct i2s_dai *cpu_dai = NULL;
+		cpu_dai = dev_get_drvdata(&pdev->dev);
+		if (!cpu_dai) {
 			dev_err(&pdev->dev, "Unable to get drvdata\n");
 			return -EFAULT;
 		}
-		devm_snd_soc_register_component(&sec_dai->pdev->dev,
-						&samsung_i2s_component,
-						&sec_dai->i2s_dai_drv, 1);
-		samsung_asoc_dma_platform_register(&pdev->dev);
+
+		if (samsung_dai_type == TYPE_SEC) {
+			snd_soc_register_component(&cpu_dai->pdev->dev,
+					&samsung_i2s_component,
+					&cpu_dai->i2s_dai_drv, 1);
+#ifdef CONFIG_SND_SAMSUNG_FAKEDMA
+			asoc_fdma_platform_register(&pdev->dev, &cpu_ops);
+#else
+			asoc_dma_platform_register(&pdev->dev);
+#endif
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		} else if (samsung_dai_type == TYPE_COMPR) {
+			cpu_dai->i2s_dai_drv.compress_dai = 1;
+			snd_soc_register_component(&cpu_dai->pdev->dev,
+					&samsung_i2s_component,
+					&cpu_dai->i2s_dai_drv, 1);
+			asoc_compr_platform_register(&pdev->dev);
+#endif
+		}
 		return 0;
 	}
 
-	pri_dai = i2s_alloc_dai(pdev, false);
+	pri_dai = i2s_alloc_dai(pdev, TYPE_PRI, quirks);
 	if (!pri_dai) {
 		dev_err(&pdev->dev, "Unable to alloc I2S_pri\n");
 		return -ENOMEM;
@@ -1180,18 +1807,62 @@ static int samsung_i2s_probe(struct platform_device *pdev)
 
 		if (i2s_cfg) {
 			quirks = i2s_cfg->quirks;
+#ifdef CONFIG_SND_SAMSUNG_IDMA
 			idma_addr = i2s_cfg->idma_addr;
+#endif
 		}
 	} else {
-		quirks = i2s_dai_data->quirks;
-		if (of_property_read_u32(np, "samsung,idma-addr",
-					 &idma_addr)) {
-			if (quirks & QUIRK_SEC_DAI) {
-				dev_err(&pdev->dev, "idma address is not"\
-						"specified");
-				return -EINVAL;
+		if (of_find_property(np, "samsung,supports-6ch", NULL))
+			quirks |= QUIRK_PRI_6CHAN;
+
+		if (of_find_property(np, "samsung,supports-secdai", NULL))
+			quirks |= QUIRK_SEC_DAI;
+
+		if (of_find_property(np, "samsung,supports-rstclr", NULL))
+			quirks |= QUIRK_NEED_RSTCLR;
+
+		if (of_find_property(np, "samsung,supports-tdm", NULL)) {
+			quirks |= QUIRK_SUPPORTS_TDM;
+			of_property_read_u32(np, "samsung,tdm-slotnum", &slotnum);
+			if (!slotnum)
+				pri_dai->slotnum = I2S_DEFAULT_SLOT_NUM;
+			dev_info(&pdev->dev, "TDM mode was applied : %d\n",
+				slotnum);
+		}
+
+		if (of_find_property(np, "samsung,supports-low-rfs", NULL))
+			quirks |= QUIRK_SUPPORTS_LOW_RFS;
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+		if (of_find_property(np, "samsung,supports-idma", NULL)) {
+			quirks |= QUIRK_IDMA;
+
+			if (of_property_read_u32(np, "samsung,idma-addr",
+						 &idma_addr)) {
+				if (quirks & QUIRK_SEC_DAI) {
+					dev_err(&pdev->dev, "idma address is not"\
+							"specified");
+					return -EINVAL;
+				}
 			}
 		}
+#endif
+		if (of_find_property(np, "samsung,supports-esa-dma", NULL))
+			quirks |= QUIRK_ESA_DMA;
+
+		if (of_find_property(np, "samsung,supports-sec-compr", NULL))
+			quirks |= QUIRK_SEC_DAI_COMPR;
+
+		if (of_property_read_u32(np, "samsung,amixer", &amixer))
+			amixer = 0;
+
+		if (of_find_property(np, "samsung,i2s-str", NULL))
+			quirks |= QUIRK_I2S_STR_MODE;
+
+		if (of_find_property(np, "samsung,supports-i2s-amp", NULL))
+			quirks |= QUIRK_I2S_DAI_AMP;
+
+		if (of_find_property(np, "samsung,lpass-subip", NULL))
+			lpass_register_subip(&pdev->dev, "i2s");
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1207,57 +1878,146 @@ static int samsung_i2s_probe(struct platform_device *pdev)
 	}
 	regs_base = res->start;
 
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get irq resource\n");
+		return -ENXIO;
+	}
+	pri_dai->irq = res->start;
+
 	pri_dai->dma_playback.dma_addr = regs_base + I2STXD;
 	pri_dai->dma_capture.dma_addr = regs_base + I2SRXD;
+	pri_dai->dma_playback.client =
+		(struct s3c2410_dma_client *)&pri_dai->dma_playback;
 	pri_dai->dma_playback.ch_name = "tx";
+	pri_dai->dma_capture.client =
+		(struct s3c2410_dma_client *)&pri_dai->dma_capture;
 	pri_dai->dma_capture.ch_name = "rx";
 	pri_dai->dma_playback.dma_size = 4;
 	pri_dai->dma_capture.dma_size = 4;
 	pri_dai->base = regs_base;
 	pri_dai->quirks = quirks;
+	pri_dai->amixer = amixer;
+	pri_dai->slotnum = slotnum;
 
 	if (quirks & QUIRK_PRI_6CHAN)
 		pri_dai->i2s_dai_drv.playback.channels_max = 6;
 
+	if (quirks & QUIRK_ESA_DMA) {
+		pri_dai->dma_playback.esa_dma = true;
+		pri_dai->dma_capture.esa_dma = true;
+	}
+
 	if (quirks & QUIRK_SEC_DAI) {
-		sec_dai = i2s_alloc_dai(pdev, true);
+		sec_dai = i2s_alloc_dai(pdev, TYPE_SEC, quirks);
 		if (!sec_dai) {
 			dev_err(&pdev->dev, "Unable to alloc I2S_sec\n");
 			ret = -ENOMEM;
 			goto err;
 		}
 		sec_dai->dma_playback.dma_addr = regs_base + I2STXDS;
+		sec_dai->dma_playback.client =
+			(struct s3c2410_dma_client *)&sec_dai->dma_playback;
 		sec_dai->dma_playback.ch_name = "tx-sec";
 
 		if (!np)
 			sec_dai->dma_playback.slave = i2s_pdata->dma_play_sec;
 
+		sec_dai->slotnum = pri_dai->slotnum;
 		sec_dai->dma_playback.dma_size = 4;
 		sec_dai->base = regs_base;
 		sec_dai->quirks = quirks;
+#ifdef CONFIG_SND_SAMSUNG_IDMA
 		sec_dai->idma_playback.dma_addr = idma_addr;
+#endif
+		if (quirks & QUIRK_ESA_DMA)
+			sec_dai->dma_playback.esa_dma = true;
+
 		sec_dai->pri_dai = pri_dai;
 		pri_dai->sec_dai = sec_dai;
+
+		if (np)
+			sec_dai->pdev->dev.of_node = of_get_child_by_name(np, "i2s-sec");
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+		/* Register Compress CPU DAI */
+		compr_dai = i2s_alloc_dai(pdev, TYPE_COMPR, quirks);
+		if (!compr_dai) {
+			dev_err(&pdev->dev, "Unable to alloc I2S_compr\n");
+			ret = -ENOMEM;
+			goto err;
+		}
+		compr_dai->slotnum = pri_dai->slotnum;
+		compr_dai->dma_playback.dma_addr = regs_base + I2STXDS;
+		compr_dai->dma_playback.client =
+			(struct s3c2410_dma_client *)&compr_dai->dma_playback;
+		compr_dai->dma_playback.ch_name = "tx-sec";
+		compr_dai->dma_playback.dma_size = 4;
+		compr_dai->base = regs_base;
+		compr_dai->quirks = quirks;
+		compr_dai->dma_playback.esa_dma = true;
+		compr_dai->dma_playback.compr_dma = true;
+		compr_dai->dma_playback.sec_dma_dev = &sec_dai->pdev->dev;
+		pr_info("Compress dai : sec_dai = %s\n",
+				dev_name(&sec_dai->pdev->dev));
+
+		compr_dai->pri_dai = pri_dai;
+		compr_dai->sec_dai = sec_dai;
+		compr_dai->is_compress = true;
+		pri_dai->compr_dai = compr_dai;
+		sec_dai->compr_dai = compr_dai;
+
+		if (np)
+			compr_dai->pdev->dev.of_node = of_get_child_by_name(np, "i2s-compr");
+#endif
 	}
 
-	if (i2s_pdata && i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {
-		dev_err(&pdev->dev, "Unable to configure gpio\n");
-		ret = -EINVAL;
-		goto err;
+	if (quirks & QUIRK_I2S_DAI_AMP)
+		pri_dai->sec_dai = pri_dai;
+
+	if (!np) {
+		if (i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {
+			dev_err(&pdev->dev, "Unable to configure gpio\n");
+			ret = -EINVAL;
+			goto err;
+		}
+	} else {
+		pinctrl = devm_pinctrl_get(&pdev->dev);
+		if (IS_ERR(pinctrl)) {
+			dev_warn(&pdev->dev, "did not get pins for i2s: %li\n",
+				PTR_ERR(pinctrl));
+		} else {
+			pri_dai->pinctrl = pinctrl;
+			if (quirks & QUIRK_SEC_DAI) {
+				sec_dai->pinctrl = pinctrl;
+#ifdef CONFIG_SND_SAMSUNG_COMPR
+				compr_dai->pinctrl = pinctrl;
+#endif
+			}
+		}
 	}
+	i2s_cfg_gpio(pri_dai, "idle");
 
-	devm_snd_soc_register_component(&pri_dai->pdev->dev,
-					&samsung_i2s_component,
-					&pri_dai->i2s_dai_drv, 1);
+	snd_soc_register_component(&pri_dai->pdev->dev, &samsung_i2s_component,
+				   &pri_dai->i2s_dai_drv, 1);
 
-	pm_runtime_enable(&pdev->dev);
+	if (pri_dai->amixer)
+		eax_dev_register(&pri_dai->pdev->dev, "i2s",
+			     &pri_dai->dma_playback, pri_dai->amixer);
 
-	samsung_asoc_dma_platform_register(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
 
+#ifdef CONFIG_SND_SAMSUNG_FAKEDMA
+	asoc_fdma_platform_register(&pdev->dev, &cpu_ops);
+#else
+	asoc_dma_platform_register(&pdev->dev);
+#endif
+#ifdef CONFIG_SND_SAMSUNG_IDMA
+	if (quirks & QUIRK_IDMA)
+		asoc_idma_platform_register(&pdev->dev);
+#endif
 	return 0;
 err:
-	if (res)
-		release_mem_region(regs_base, resource_size(res));
+	release_mem_region(regs_base, resource_size(res));
 
 	return ret;
 }
@@ -1283,56 +2043,41 @@ static int samsung_i2s_remove(struct platform_device *pdev)
 	i2s->pri_dai = NULL;
 	i2s->sec_dai = NULL;
 
+#ifdef CONFIG_SND_SAMSUNG_FAKEDMA
+	asoc_fdma_platform_unregister(&pdev->dev);
+#else
+	asoc_dma_platform_unregister(&pdev->dev);
+#endif
+	snd_soc_unregister_component(&pdev->dev);
+
 	return 0;
 }
 
-static const struct samsung_i2s_dai_data i2sv3_dai_type = {
-	.dai_type = TYPE_PRI,
-	.quirks = QUIRK_NO_MUXPSR,
-};
-
-static const struct samsung_i2s_dai_data i2sv5_dai_type = {
-	.dai_type = TYPE_PRI,
-	.quirks = QUIRK_PRI_6CHAN | QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR,
-};
-
-static const struct samsung_i2s_dai_data i2sv6_dai_type = {
-	.dai_type = TYPE_PRI,
-	.quirks = QUIRK_PRI_6CHAN | QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR |
-			QUIRK_SUPPORTS_TDM,
-};
-
-static const struct samsung_i2s_dai_data samsung_dai_type_pri = {
-	.dai_type = TYPE_PRI,
-};
-
-static const struct samsung_i2s_dai_data samsung_dai_type_sec = {
-	.dai_type = TYPE_SEC,
-};
-
 static struct platform_device_id samsung_i2s_driver_ids[] = {
 	{
 		.name           = "samsung-i2s",
-		.driver_data    = (kernel_ulong_t)&samsung_dai_type_pri,
+		.driver_data	= TYPE_PRI,
 	}, {
 		.name           = "samsung-i2s-sec",
-		.driver_data    = (kernel_ulong_t)&samsung_dai_type_sec,
+		.driver_data	= TYPE_SEC,
+	}, {
+		.name           = "samsung-i2s-compr",
+		.driver_data	= TYPE_COMPR,
 	},
 	{},
 };
 MODULE_DEVICE_TABLE(platform, samsung_i2s_driver_ids);
 
 #ifdef CONFIG_OF
+static struct samsung_i2s_dai_data samsung_i2s_dai_data_array[] = {
+	[TYPE_PRI] = { TYPE_PRI },
+	[TYPE_SEC] = { TYPE_SEC },
+	[TYPE_COMPR] = { TYPE_COMPR },
+};
+
 static const struct of_device_id exynos_i2s_match[] = {
-	{
-		.compatible = "samsung,s3c6410-i2s",
-		.data = &i2sv3_dai_type,
-	}, {
-		.compatible = "samsung,s5pv210-i2s",
-		.data = &i2sv5_dai_type,
-	}, {
-		.compatible = "samsung,exynos5420-i2s",
-		.data = &i2sv6_dai_type,
+	{ .compatible = "samsung,i2s-v5",
+	  .data = &samsung_i2s_dai_data_array[TYPE_PRI],
 	},
 	{},
 };
